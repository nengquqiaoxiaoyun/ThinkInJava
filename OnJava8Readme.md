## 第一章 对象导论

### 1.1 抽象过程

所有编程语言都提供抽象机制。

OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。但是它仍然与计算机有联系：每个对象看起来都有点像一台微型计算机—它具有状态，还具有操作，用户可以要求对象执行这些操作。

### 1.2 每个对象都有一个接口

所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分。

### 1.3 每个对象都提供服务

当开发或理解一个程序设计时，最好的方法是将对象想象为“服务提供者”，程序本身向用户提供服务。我们的目标就是去创建（或使用已存在的）能够提供理想的服务来解决问题的一系列对象。

人们在设计面向对象时所面临的一个问题是，将过多的功能都塞在一个对象中。

在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事情。

### 1.4 被隐藏的具体实现 （封装）

如果所有的类成员对任何人都是可用的，那么客户端程序员（调用方）就可以对类做任何事情。将实现隐藏起来，创建者可以任意修改而不用担心对其他人造成影响。（对他人造成影响是说，随意修改属性值可能对他人的值产生影响。公开的属性将直接拿到真正的对象，而get拿到的是对象的副本，可变类除外）

### 1.5 复用具体实现

组合（Composition）继承被视为“has a”（拥有）关系。

在建立新类时，应该优先考虑组合，因为它更加简单灵活。

### 1.7 伴随多态的可互换对象

在OOP中，程序知道运行时才能够确定代码的地址。面向对象程序设计语言使用了后期绑定的概念。当向被调用的代码发出消息时，被调用的代码直到运行时才能确定。Java使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。这样，根据这一小段代码的内容， 每个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道对这条消息做什么。

Java的动态绑定是默认行为。

### 1.8 单继承结构

单根继承结构使垃圾回收器的实现变得容易得多。由于所有的对象都保证具有其类型信息，因此不会因为无法确定对象的类型而陷入僵局。

### 1.10 对象的创建和生命周期

垃圾回收器“知道”对象何时不再被使用，并自动释放对象占用的内存。这一点同所有对象都是继承自单根基类Object以及**只能以一种方式创建对象（在堆上创建）**这两个特性结合起来

### 1.14 总结

通常按照 Java 规范编写的程序会比面向过程程序更容易被理解。

你看到的是对象的概念，这些概念是站在“问题空间”（问题本身）的（而不是站在计算机角度的“解决方案空间”），以及发送消息给对象以指示该空间中的活动。面向对象编程的一个优点是：设计良好的 Java 程序代码更容易被人阅读理解。由于 Java 类库的复用性，通常程序要写的代码也会少得多。

